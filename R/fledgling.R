#' fledgling object
#'
#' Contains the information that fledge manages about a repository.
#' The internal structure of this object is subject to change.
#'
#' @param name The name of the package
#' @param version A [package_version] that describes the current version
#' @param date The package date, or `NULL` if not present in `DESCRIPTION`
#' @param preamble The text that appears before the first section header
#' @param news A data frame FIXME
#' @noRd
new_fledgling <- function(name, version, date, preamble, news) {
  structure(
    list(
      name = name,
      version = version,
      date = date,
      preamble = preamble,
      news = news
    ),
    class = "fledgling"
  )
}

read_package <- function() {
  unname(desc::desc_get("Package"))
}

read_version <- function() {
  desc::desc_get_version()
}

read_date <- function() {
  desc::desc_get_field("Date", default = NULL)
}

read_news <- function(news_lines = NULL) {
  if (is.null(news_lines)) {
    if (file.exists("NEWS.md")) {
      news_lines <- readLines("NEWS.md")
    } else {
      news_lines <- character()
    }
  }

  news <- parse_news_md(news_lines, strict = TRUE)

  if (is.null(news)) {
    return(
      list(
        section_df = NULL,
        preamble = news_preamble()
      )
    )
  }

  # NEWS content under no version
  if (length(news) == 1 && !nzchar(names(news))) {
    rlang::abort("NEWS content not under a version header")
  }

  # match parsed headers to the Markdown
  get_section_start <- function(section_title, news_lines) {
    escaped_section_title <- sub("\\(", "\\\\(", section_title)
    escaped_section_title <- sub("\\)", "\\\\)", escaped_section_title)
    section_start <- which(grepl(sprintf("^#+ +%s[:space:]?$", escaped_section_title), news_lines))

    if (length(section_start) == 0) {
      # what to do
    }

    if (length(section_start) > 1) {
      # what to do
    }
    section_start
  }

  starts <- purrr::map_int(names(news), get_section_start, news_lines)

  ends <- if (length(starts) == 1) {
    length(news_lines)
  } else {
    c(starts[seq_along(starts[-1]) + 1] - 1, length(news_lines))
  }

  section_df <- tibble::tibble(
    start = starts,
    end = ends,
    h2 = grepl("##", news_lines[starts]), # TODO does not account for all syntaxes,
    raw = map2_chr(starts, ends, ~ paste(news_lines[seq2(.x, .y)], collapse = "\n")),
    news = split(news, seq_len(length(news)))
  )

  section_df$section_state <- "keep"

  section_df$title <- names(news)

  find_version <- function(text) {
    m <- regmatches(
      text,
      regexpr("[0-9]*\\.[0-9]*\\.[0-9]*(\\.[0-9]*)*", text)
    )
    if (length(m) == 0) {
      if (grepl("(development version)", text)) {
        return("(development version)")
      } else {
        return(NA_character_)
      }
    }
    m
  }
  section_df$version <- purrr::map_chr(names(news), find_version)

  find_date <- function(text) {
    m <- regmatches(
      text,
      regexpr('\\(....-..-..\\)', text)
    )
    if (length(m) == 0) {
      return(NA_character_)
    }
    m
  }
  section_df$date <- purrr::map_chr(names(news), find_date)

  find_nickname <- function(text) {
    m <- regmatches(
      text,
      regexpr('".*"', text)
    )
    if (length(m) == 0) {
      return(NA_character_)
    }
    m
  }
  section_df$nickname <- purrr::map_chr(names(news), find_nickname)


  fix_name_and_level <- function(news_list) {
    if (is.null(news_list)) {
      return(news_list)
    }

    if (!is.list(news_list[[1]])) {
      if (length(news_list[[1]]) == 1 && !nzchar(news_list[[1]])) {
        return(NULL)
      }
      names(news_list) <- default_type()
      return(news_list)
    }

    unlist(news_list[[1]], recursive = FALSE)
  }
  section_df$news <- map(section_df$news, fix_name_and_level)

  # create, update or re-use preamble
  is_preamble_absent <- (section_df[["start"]][[1]] == 1)
  if (is_preamble_absent) {
    preamble <- NULL
  } else {
    preamble <- trim_empty_lines(news_lines[seq2(1, section_df[["start"]][[1]] - 1)])

    is_outdated_fledge_preamble <- (trimws(preamble) %in% old_news_preambles())
    if (is_outdated_fledge_preamble) preamble <- news_preamble()

    # FIXME: check the "preamble" is an HTML comment?
  }
  list(
    section_df = section_df,
    preamble = if (!is.null(preamble)) paste(preamble, collapse = "\n")
  )
}

read_fledgling <- function() {
  package <- read_package()
  version <- read_version()
  date <- read_date()

  news_and_preamble <- read_news()
  news_and_preamble[["preamble"]] <- news_and_preamble[["preamble"]] %||% news_preamble()

  new_fledgling(package, version, date, news_and_preamble[["preamble"]], news_and_preamble[["section_df"]])
}

trim_empty_lines <- function(x) {
  for (start in seq_along(x)) {
    if (x[[start]] != "") {
      break
    }
  }

  for (end in rev(seq2(start, length(x)))) {
    if (x[[end]] != "") {
      break
    }
  }

  x[seq2(start, end)]
}

write_fledgling <- function(fledgeling) {
  # store version
  desc::desc_set_version(
    fledgeling$version,
    file = "DESCRIPTION"
  )

  if (!is.null(fledgeling$date)) {
    desc::desc_set(Date = fledgeling$date)
  }

  # store news

  news_df <- fledgeling$news
  news_lines <- purrr::map_chr(
    split(news_df, sort(as.numeric(rownames(news_df)))),
    write_news_section
  )
  news_lines <- unprotect_hashtag(news_lines)

  lines <- c(
    fledgeling[["preamble"]], "",
    paste0(news_lines, collapse = "\n\n")
  )
  brio::write_lines(lines, news_path())
}

write_news_section <- function(df) {
  # isTRUE as sometimes there is no previous header
  # so h2 is NULL not FALSE
  if (df$section_state == "keep") {
    # remove the lines that will be re-added
    raw <- sub("\n$", "", df$raw)
    return(raw)
  }

  if (isTRUE(df$h2)) {
    header_sign <- "##"
  } else {
    header_sign <- "#"
  }

  version_header <- trimws(
    sprintf(
      "%s %s %s %s %s",
      header_sign,
      read_package(),
      df$version,
      if (!is.na(df$date)) df$date else "",
      if (!is.na(df$nickname)) df$nickname else ""
    )
  )

  # If only uncategorized items for the version, no subheaders
  if (length(df$news[[1]]) == 1 && names(df$news[[1]]) == default_type()) {
    section_lines <- c(
      version_header, "",
      paste(df$news[[1]][[1]], collapse = "\n"), ""
    )
  } else {
    if (isTRUE(df$h2)) {
      header_level <- 3
    } else {
      header_level <- 2
    }

    section_lines <- c(
      version_header, "",
      format_news_subsections(df$news[[1]], header_level), ""
    )
  }
  paste0(section_lines, collapse = "\n")
}

format_news_subsections <- function(news_list, header_level) {
  header_sign <- paste(rep("#", header_level), collapse = "")

  lines <- purrr::imap_chr(
    news_list,
    ~ sprintf(
      "%s %s\n\n%s",
      header_sign,
      .y,
      paste_news_lines(.x, header_level = header_level + 1)
    ),
  )

  paste(lines, collapse = "\n\n")
}

paste_news_lines <- function(lines, header_level) {
  lines <- unlist(lines, recursive = FALSE)
  if (is_any_named(lines)) {
    header_sign <- paste(rep("#", header_level), collapse = "")
    sub_header <- function(x, header_sign) {
      if (!nzchar(x)) {
        ""
      } else {
        paste(header_sign, x, "\n\n")
      }
    }
    lines <- purrr::imap_chr(
      lines,
      ~ sprintf(
        "%s%s",
        sub_header(.y, header_sign),
        paste_news_lines(.x, header_level = header_level + 1)
      )
    )
    paste(lines, collapse = "\n\n")
  } else {
    paste(lines, collapse = "\n")
  }
}
